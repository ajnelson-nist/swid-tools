<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>FirmwarePayloadBuilder.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">SWID Tag Generation Java API</a> &gt; <a href="index.source.html" class="el_package">gov.nist.secauto.swid.builder.resource.firmware</a> &gt; <span class="el_source">FirmwarePayloadBuilder.java</span></div><h1>FirmwarePayloadBuilder.java</h1><pre class="source lang-java linenums">/**
 * Portions of this software was developed by employees of the National Institute
 * of Standards and Technology (NIST), an agency of the Federal Government and is
 * being made available as a public service. Pursuant to title 17 United States
 * Code Section 105, works of NIST employees are not subject to copyright
 * protection in the United States. This software may be subject to foreign
 * copyright. Permission in the United States and in foreign countries, to the
 * extent that NIST may hold copyright, to use, copy, modify, create derivative
 * works, and distribute this software and its documentation without fee is hereby
 * granted on a non-exclusive basis, provided that this notice and disclaimer
 * of warranty appears in all copies.
 *
 * THE SOFTWARE IS PROVIDED 'AS IS' WITHOUT ANY WARRANTY OF ANY KIND, EITHER
 * EXPRESSED, IMPLIED, OR STATUTORY, INCLUDING, BUT NOT LIMITED TO, ANY WARRANTY
 * THAT THE SOFTWARE WILL CONFORM TO SPECIFICATIONS, ANY IMPLIED WARRANTIES OF
 * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND FREEDOM FROM
 * INFRINGEMENT, AND ANY WARRANTY THAT THE DOCUMENTATION WILL CONFORM TO THE
 * SOFTWARE, OR ANY WARRANTY THAT THE SOFTWARE WILL BE ERROR FREE.  IN NO EVENT
 * SHALL NIST BE LIABLE FOR ANY DAMAGES, INCLUDING, BUT NOT LIMITED TO, DIRECT,
 * INDIRECT, SPECIAL OR CONSEQUENTIAL DAMAGES, ARISING OUT OF, RESULTING FROM,
 * OR IN ANY WAY CONNECTED WITH THIS SOFTWARE, WHETHER OR NOT BASED UPON WARRANTY,
 * CONTRACT, TORT, OR OTHERWISE, WHETHER OR NOT INJURY WAS SUSTAINED BY PERSONS OR
 * PROPERTY OR OTHERWISE, AND WHETHER OR NOT LOSS WAS SUSTAINED FROM, OR AROSE OUT
 * OF THE RESULTS OF, OR USE OF, THE SOFTWARE OR SERVICES PROVIDED HEREUNDER.
 */

package gov.nist.secauto.swid.builder.resource.firmware;

import gov.nist.secauto.swid.builder.AbstractBuilder;
import gov.nist.secauto.swid.builder.ValidationException;
import gov.nist.secauto.swid.builder.resource.HashAlgorithm;
import gov.nist.secauto.swid.builder.resource.HashUtils;
import gov.nist.secauto.swid.builder.util.Util;

import java.io.BufferedInputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.math.BigInteger;
import java.security.NoSuchAlgorithmException;
import java.util.LinkedList;
import java.util.List;
import java.util.Objects;

<span class="fc" id="L46">public class FirmwarePayloadBuilder extends AbstractBuilder {</span>

  private FirmwareIdentifier id;
  private String packageIdentifier;
  private String description;
  private Integer formatType;
  private byte[] formatGuidance;
  private BigInteger size;
  private BigInteger simpleVersion;
  // private FirmwarePayloadVersion version;
<span class="fc" id="L56">  private List&lt;FirmwarePayloadDigest&gt; digests = new LinkedList&lt;&gt;();</span>
  private String componentIndex;
  private FirmwareIdentifier storageId;
<span class="fc" id="L59">  private List&lt;FirmwareRequirement&lt;FirmwareCondition&gt;&gt; conditions = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L60">  private List&lt;FirmwareRequirement&lt;FirmwareDirective&gt;&gt; directives = new LinkedList&lt;&gt;();</span>
  // private VersionedDependency targetDependency;
  // private MinimalVersion targetMinimalVersion;
  // private List&lt;FirmwarePayloadRelationship&gt; relationships;
  private FirmwarePayloadPackage firmwarePackage;

  /**
   * Retrieve the identifier of the firmware payload.
   * 
   * @return the id
   */
  public FirmwareIdentifier getId() {
<span class="fc" id="L72">    return id;</span>
  }

  /**
   * Set the id of the firmware payload.
   * 
   * @param id
   *          the firmware's identifier
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder id(FirmwareIdentifier id) {
<span class="fc" id="L83">    Objects.requireNonNull(id, &quot;id&quot;);</span>
<span class="fc" id="L84">    this.id = id;</span>
<span class="fc" id="L85">    return this;</span>
  }

  /**
   * Retrieve the package identifier of the firmware manifest.
   * 
   * @return the packageIdentifier
   */
  public String getPackageIdentifier() {
<span class="fc" id="L94">    return packageIdentifier;</span>
  }

  /**
   * Set the package identifier.
   * 
   * @param packageIdentifier
   *          a {@code non-null} package identifier
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder packageIdentifier(String packageIdentifier) {
<span class="nc" id="L105">    Util.requireNonEmpty(packageIdentifier, &quot;packageIdentifier&quot;);</span>
<span class="nc" id="L106">    this.packageIdentifier = packageIdentifier;</span>
<span class="nc" id="L107">    return this;</span>
  }

  /**
   * Retrieve the description of the firmware payload.
   * 
   * @return the description
   */
  public String getDescription() {
<span class="fc" id="L116">    return description;</span>
  }

  /**
   * Set the version of the firmware payload.
   * 
   * @param description
   *          the firmware's description
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder description(String description) {
<span class="nc" id="L127">    Util.requireNonEmpty(description, &quot;description&quot;);</span>
<span class="nc" id="L128">    this.description = description;</span>
<span class="nc" id="L129">    return this;</span>
  }

  /**
   * Retrieve the format type of the firmware payload.
   * 
   * @return the type
   */
  public int getFormatType() {
<span class="fc" id="L138">    return formatType;</span>
  }

  /**
   * Set the format type.
   * 
   * @param type
   *          a format type
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder formatType(int type) {
<span class="fc" id="L149">    this.formatType = type;</span>
<span class="fc" id="L150">    return this;</span>
  }

  /**
   * Retrieve the firmware payload's format guidance.
   * 
   * @return the format guidance
   */
  public byte[] getFormatGuidance() {
<span class="fc" id="L159">    return formatGuidance;</span>
  }

  /**
   * Set the firmware payload's format guidance.
   * 
   * @param bytes
   *          guidance a {@code non-null} byte string
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder formatGuidance(byte[] bytes) {
<span class="nc" id="L170">    Objects.requireNonNull(bytes, &quot;bytes&quot;);</span>
<span class="nc" id="L171">    this.formatGuidance = bytes;</span>
<span class="nc" id="L172">    return this;</span>
  }

  /**
   * Retrieve the size the firmware payload.
   * 
   * @return the size
   */
  public BigInteger getSize() {
<span class="fc" id="L181">    return size;</span>
  }

  /**
   * Set the size.
   * 
   * @param size
   *          a {@code non-null} size
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder size(BigInteger size) {
<span class="fc" id="L192">    Objects.requireNonNull(size, &quot;size&quot;);</span>
<span class="fc" id="L193">    this.size = size;</span>
<span class="fc" id="L194">    return this;</span>
  }

  /**
   * Retrieve the simple version of the firmware payload.
   * 
   * @return the version
   */
  public BigInteger getSimpleVersion() {
<span class="nc" id="L203">    return simpleVersion;</span>
  }

  // /**
  // * Set the version of the payload.
  // *
  // * @param version
  // * a {@code non-null} version
  // * @return the same builder instance
  // */
  // public FirmwarePayloadBuilder version(FirmwarePayloadVersion version) {
  // Objects.requireNonNull(version, &quot;version&quot;);
  // this.version = version;
  // return this;
  // }
  //
  // /**
  // * Retrieve the simple version of the firmware payload.
  // *
  // * @return the version
  // */
  // public FirmwarePayloadVersion getVersion() {
  // return version;
  // }

  /**
   * Set the simple version of the payload.
   * 
   * @param version
   *          a {@code non-null} version
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder simpleVersion(BigInteger version) {
<span class="nc" id="L236">    Objects.requireNonNull(version, &quot;version&quot;);</span>
<span class="nc" id="L237">    this.simpleVersion = version;</span>
<span class="nc" id="L238">    return this;</span>
  }

  /**
   * Retrieve the digests of the firmware payload.
   * 
   * @return the digests
   */
  public List&lt;FirmwarePayloadDigest&gt; getDigests() {
<span class="fc" id="L247">    return digests;</span>
  }

  /**
   * Adds a new digest to the list of digests.
   * 
   * @param digest
   *          the digest to add
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder addDigest(FirmwarePayloadDigest digest) {
<span class="fc" id="L258">    Objects.requireNonNull(digest, &quot;digest&quot;);</span>
<span class="fc" id="L259">    this.digests.add(digest);</span>
<span class="fc" id="L260">    return this;</span>
  }

  /**
   * Sets the to-be-built file's hash value, for the provided algorithm, to the provided value. An
   * {@link InputStream} is used to retrieve the files contents to calculate the hash value. The
   * caller is responsible for closing the stream used by this method.
   * 
   * @param type
   *          the type of resource this digest is for
   * @param algorithm
   *          the algorithm to establish a hash value for
   * @param file
   *          the file to hash
   * @return the same builder instance
   * @throws NoSuchAlgorithmException
   *           if the hash algorithm is not supported
   * @throws IOException
   *           if an error occurs while reading the stream
   */
  public FirmwarePayloadBuilder addDigest(DigestType type, HashAlgorithm algorithm, File file)
      throws NoSuchAlgorithmException, IOException {
<span class="nc" id="L282">    try (InputStream is = new BufferedInputStream(new FileInputStream(file))) {</span>
<span class="nc" id="L283">      return addDigest(type, algorithm, is);</span>
    }
  }

  /**
   * Sets the file's hash value, for the provided algorithm, to the provided value. An
   * {@link InputStream} is used to retrieve the files contents to calculate the hash value. The
   * caller is responsible for closing the stream used by this method.
   * 
   * @param type
   *          the type of resource this digest is for
   * @param algorithm
   *          the algorithm to establish a hash value for
   * @param is
   *          an {@link InputStream} that can be used to read the file
   * @return the same builder instance
   * @throws NoSuchAlgorithmException
   *           if the hash algorithm is not supported
   * @throws IOException
   *           if an error occurs while reading the stream
   */
  public FirmwarePayloadBuilder addDigest(DigestType type, HashAlgorithm algorithm, InputStream is)
      throws NoSuchAlgorithmException, IOException {
<span class="nc" id="L306">    byte[] digest = HashUtils.hash(algorithm, is);</span>
<span class="nc" id="L307">    return addDigest(type, algorithm, digest);</span>
  }

  /**
   * Sets the file's hash value, for the provided algorithm, to the provided value.
   * 
   * @param type
   *          the type of resource this digest is for
   * @param algorithm
   *          the algorithm to establish a hash value for
   * @param digest
   *          an array of bytes representing the digest value
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder addDigest(DigestType type, HashAlgorithm algorithm, byte[] digest) {
<span class="fc" id="L322">    Objects.requireNonNull(type, &quot;type&quot;);</span>
<span class="fc" id="L323">    Objects.requireNonNull(algorithm, &quot;algorithm&quot;);</span>
<span class="fc" id="L324">    Objects.requireNonNull(digest, &quot;digest&quot;);</span>

<span class="fc" id="L326">    FirmwarePayloadDigest payloadDigest = new FirmwarePayloadDigest(type, algorithm, digest);</span>
<span class="fc" id="L327">    return addDigest(payloadDigest);</span>
  }

  /**
   * Retrieve the index value of the firmware component.
   * 
   * @return the componentIndex
   */
  public String getComponentIndex() {
<span class="nc" id="L336">    return componentIndex;</span>
  }

  /**
   * Set the component index.
   * 
   * @param componentIndex
   *          a {@code non-null} component index
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder componentIndex(String componentIndex) {
<span class="nc" id="L347">    Util.requireNonEmpty(componentIndex, &quot;componentIndex&quot;);</span>
<span class="nc" id="L348">    this.componentIndex = componentIndex;</span>
<span class="nc" id="L349">    return this;</span>
  }

  /**
   * Retrieve the storage id of the firmware component.
   * 
   * @return the storage id
   */
  public FirmwareIdentifier getStorageId() {
<span class="fc" id="L358">    return storageId;</span>
  }

  /**
   * Set the storage id.
   * 
   * @param id
   *          a {@code non-null} storage id
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder storageId(FirmwareIdentifier id) {
<span class="fc" id="L369">    Objects.requireNonNull(id, &quot;storageId&quot;);</span>
<span class="fc" id="L370">    this.storageId = id;</span>
<span class="fc" id="L371">    return this;</span>
  }

  /**
   * Retrieve the conditions of the firmware payload.
   * 
   * @return the conditions
   */
  public List&lt;FirmwareRequirement&lt;FirmwareCondition&gt;&gt; getConditions() {
<span class="nc" id="L380">    return conditions;</span>
  }

  /**
   * Adds a new condition to the list of conditions.
   * 
   * @param condition
   *          the condition to add
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder addCondition(FirmwareRequirement&lt;FirmwareCondition&gt; condition) {
<span class="nc" id="L391">    Objects.requireNonNull(condition, &quot;condition&quot;);</span>
<span class="nc" id="L392">    this.conditions.add(condition);</span>
<span class="nc" id="L393">    return this;</span>
  }

  /**
   * Retrieve the directives of the firmware payload.
   * 
   * @return the directives
   */
  public List&lt;FirmwareRequirement&lt;FirmwareDirective&gt;&gt; getDirectives() {
<span class="nc" id="L402">    return directives;</span>
  }

  /**
   * Adds a new directive to the list of directives.
   * 
   * @param directive
   *          the directive to add
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder addDirective(FirmwareRequirement&lt;FirmwareDirective&gt; directive) {
<span class="nc" id="L413">    Objects.requireNonNull(directive, &quot;directive&quot;);</span>
<span class="nc" id="L414">    this.directives.add(directive);</span>
<span class="nc" id="L415">    return this;</span>
  }

  // /**
  // * Retrieve the targetDependency of the firmware component.
  // *
  // * @return the targetDependency
  // */
  // public VersionedDependency getTargetDependency() {
  // return targetDependency;
  // }
  //
  // /**
  // * Set the component targetDependency.
  // *
  // * @param targetDependency
  // * a {@code non-null} targetDependency
  // * @return the same builder instance
  // */
  // public FirmwarePayloadBuilder targetDependency(VersionedDependency
  // targetDependency) {
  // Objects.requireNonNull(targetDependency, &quot;targetDependency&quot;);
  // this.targetDependency = targetDependency;
  // return this;
  // }

  // /**
  // * Retrieve the targetMinimalVersion of the firmware component.
  // *
  // * @return the targetMinimalVersion
  // */
  // public MinimalVersion getTargetMinimalVersion() {
  // return targetMinimalVersion;
  // }
  //
  // /**
  // * Set the component targetMinimalVersion.
  // *
  // * @param targetMinimalVersion
  // * a {@code non-null} targetMinimalVersion
  // * @return the same builder instance
  // */
  // public FirmwarePayloadBuilder targetMinimalVersion(MinimalVersion
  // targetMinimalVersion) {
  // Objects.requireNonNull(targetDependency, &quot;targetDependency&quot;);
  // this.targetMinimalVersion = targetMinimalVersion;
  // return this;
  // }

  // /**
  // * Retrieve the relationships of the firmware payload.
  // *
  // * @return the relationships
  // */
  // public List&lt;FirmwarePayloadRelationship&gt; getRelationships() {
  // return relationships;
  // }
  //
  // /**
  // * Adds a new relationship to the list of relationships.
  // *
  // * @param relationship
  // * the relationship to add
  // * @return the same builder instance
  // */
  // public FirmwarePayloadBuilder addRelationship(FirmwarePayloadRelationship
  // relationship) {
  // Objects.requireNonNull(relationship, &quot;relationship&quot;);
  // this.relationships.add(relationship);
  // return this;
  // }

  /**
   * Retrieve the firmwarePackage of the firmware component.
   * 
   * @return the targetMinimalVersion
   */
  public FirmwarePayloadPackage getFirmwarePackage() {
<span class="fc" id="L493">    return firmwarePackage;</span>
  }

  /**
   * Set the component firmwarePackage.
   * 
   * @param firmwarePackage
   *          a {@code non-null} firmwarePackage
   * @return the same builder instance
   */
  public FirmwarePayloadBuilder firmwarePackage(FirmwarePayloadPackage firmwarePackage) {
<span class="fc" id="L504">    Objects.requireNonNull(firmwarePackage, &quot;firmwarePackage&quot;);</span>
<span class="fc" id="L505">    this.firmwarePackage = firmwarePackage;</span>
<span class="fc" id="L506">    return this;</span>
  }

  @Override
  public void validate() throws ValidationException {
<span class="nc" id="L511">    validateNonNull(&quot;id&quot;, id);</span>
<span class="nc" id="L512">    validateNonNull(&quot;formatType&quot;, formatType);</span>
<span class="nc" id="L513">    validateNonNull(&quot;size&quot;, size);</span>
<span class="nc" id="L514">    validateNonEmpty(&quot;digests&quot;, digests);</span>
<span class="nc" id="L515">    validateNonNull(&quot;storageId&quot;, storageId);</span>
<span class="nc" id="L516">    validateNonEmpty(&quot;conditions&quot;, conditions);</span>
<span class="nc" id="L517">  }</span>

  @Override
  public void reset() {
    // TODO: implement
<span class="nc" id="L522">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>